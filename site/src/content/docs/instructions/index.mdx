---
title: 'Instructions'
author: 'BlueGummi'
tableOfContents:
    minHeadingLevel: 2
    maxHeadingLevel: 2
---

# Instruction listings

The BELLE-ISA has **16 instructions**, which were mentioned in the above opcode table. Below is a **description**, **definition**, use case, and example of every instruction.

Please refer to the [encoding](../encoding) document for more information about the **specifics on how certain arguments are encoded**, particularly the meaning of "*determinant bits*" and the different encodings that each instruction can use. This document **omits** such information for brevity's sake, as it is already quite long.

> Note: The BELLE-ISA uses 16 bit long memory addresses. This is done for simplicity's sake, as using smaller, typically standard 8-bit memory addresses requires more and typically somewhat unnecessary effort on both the emulator and programmer's side.

## 1. HLT

    ### HLT - The HALT instruction
    
    `HLT` will halt BELLE when it is encountered. The program will **stop** and gracefully exit, and **no other instructions will be executed**. 

    In binary, it is simply 16 consecutive zeros, thus making it possible to call a halt instruction by simply loading a zero into a memory address and performing a jump to the address.

    `HLT` takes no arguments, and is not compatible with any argument types.

    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | HLT  | None      | Halt BELLE | Halting once the overflow flag is set. | `hlt ; Stop the program` |

    Flags affected: `running` state.

    ### Binary encoding

        Instruction: `hlt`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0000]` | `[000]` | `[0000]` | `[00000]` |

## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform **arithmetic addition**, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the **first operand**. `ADD` will always take 2 arguments, and can also perform **subtraction** if the value in RHS is **negative**. 

    `ADD` will perform **floating point arithmetic** as the 6th and 7th registers are floating-point, however the values will be cast to **integers** if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values **cannot be floating point**.



    Compatible **LHS** argument types: Register

    Compatible **RHS** argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |

## 3. JO

    ### JO - Jump if the overflow flag is set

    `JO` performs a **conditional jump**, which sets the CPU's program counter to the destination specified. `JO` will only jump if the overflow flag on the CPU is set. This flag becomes set if an **arithmetic operation** (e.g. `add`, `mul`) overflows the **destination** register.

    When `JO` is performed, the memory address that it is **performed at** is "`push`ed" onto the call stack. This memory address is known as a *return address* and is retrieved if the jump is to be returned from. Thus, if a value is to be retrieved off the stack after `JO`, the return address must first be removed, or the stack and base pointers must be adjusted. 
    
    > **Note**: The value it pushes onto the stack may **overflow a memory address**, as memory address values are signed but the addresses themselves are not. Thus, if the program is **very large** or starts at a very high memory address, it may **not be feasible** to retrieve a jumped address as it may have overflowed. This is **unlikely** unless the assembly program is above **27,000 lines of source code**.

    The overflow flag can be set **unconditionally** with `int #21`, **unset** with `int #22`, and **inverted** with `int #23`.

    As subroutines and labels in assembly **resolve to memory addresses**, `JO` will always jump to a memory address if the jump location is a subroutine, granted the destination is small enough to fit within `11` bits.

    `JO` can also take a **register pointer** argument, meaning that the value in a register is interpreted as a memory address for the destination of a jump. This must be set manually, as the assembler **will not do this**.

    Using a register as the destination can be beneficial, as `r4` and `r5` are unsigned 16 bit integers, being **able to address all memory addresses**. It is also possible to pass `r6` or `r7` - the floating point registers - to this instruction.

    If the overflow flag is **not set**, the jump will **simply be skipped**, and the next instruction will be executed accordingly.

    Compatible DEST types: Register pointer, memory address

    Flags affected: Affected by overflow flag. Cannot change any flags.
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | JO   | 1         | Jump if overflow flag is true | Leaving a loop when a register overflows | `jo $3 ; jump to address 3 if overflow flag is set` |

    
    ### Binary encoding

        Instruction: `jo &r3`

        | Opcode   | DTB     | DEST |
        | :-----   | :------ | :--- |
        | `[0010]` | `[1]` | `[00000000011]` |


## 4. POP

    ### POP - Remove the top value of the call stack and place it into a register

    `POP` reads the stack pointer, and then "`pop`s" the value contained at the stack pointer into **a destination**. The destination can only **be a register**, and `POP` will only ever take one argument. The value at the **top of the call stack** - which is referenced with the stack pointer - will be **cleared**, and the stack pointer will be adjusted depending on the direction the call stack is "going". 

    If a `POP` instruction is called **whilst the stack pointer does not point to a value**, the CPU will report a *stack underflow* - a type of segmentation fault - where the call stack does not have enough data to satisfy a `POP` instruction.

    As the **memory** is composed of **signed 16 bit integers**, the values "`pop`ped" off it will always be 16 bit signed integers. Thus, it is typically unnecessary to `pop` into a floating point register or an unsigned 16-bit register.

    Compatible DEST argument types: Register

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | POP  | 1         | Take a value off the stack | Retrieving a memory address from a JMP | `pop %r4 ; pop a value off the stack into register 4` |

    
    ### Binary encoding

        Instruction: `pop %r2`

        | Opcode   | DEST    |
        | :-----   | :------ |
        | `[0011]` | `[000000000010]` |

## 5. DIV

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


