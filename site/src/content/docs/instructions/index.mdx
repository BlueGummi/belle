---
title: 'Instructions'
author: 'BlueGummi'
tableOfContents:
    minHeadingLevel: 2
    maxHeadingLevel: 2
---

# Instruction listings

The BELLE-ISA has **16 instructions**, which were mentioned in the above opcode table. Below is a **description**, **definition**, use case, and example of every instruction.

Please refer to the [encoding](../encoding) document for more information about the **specifics on how certain arguments are encoded**, particularly the meaning of "*determinant bits*" and the different encodings that each instruction can use. This document **omits** such information for brevity's sake, as it is already quite long.

> Note: The BELLE-ISA uses 16 bit long memory addresses. This is done for simplicity's sake, as using smaller, typically standard 8-bit memory addresses requires more and typically somewhat unnecessary effort on both the emulator and programmer's side.

> Rounding: For instructions that will round a number, the number will simply have its decimal points cut off. It will not be rounded to the nearest integer, it will simply have the decimal places removed. (e.g. 4.5 becomes 4)

## 1. HLT

    ### HLT - The HALT instruction
    
    `HLT` will halt BELLE when it is encountered. The program will **stop** and gracefully exit, and **no other instructions will be executed**. 

    In binary, it is simply 16 consecutive zeros, thus making it possible to call a halt instruction by simply loading a zero into a memory address and performing a jump to the address.

    `HLT` takes no arguments, and is not compatible with any argument types.

    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | HLT  | None      | Halt BELLE | Halting once the overflow flag is set. | `hlt ; Stop the program` |

    Flags affected: `running` state.

    #### Binary encoding

        Instruction: `hlt`

        | Opcode   | Rest of instruction | 
        | :-----   | :------ |
        | `[0000]` | `[000000000000]` |

    
    ##### Pseudocode representation
        ```go
        running := false
        ```

## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform **arithmetic addition**, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the **first operand**. `ADD` will always take 2 arguments, and can also perform **subtraction** if the value in RHS is **negative**. 

    `ADD` will perform **floating point arithmetic** as the 6th and 7th registers are floating-point, however the values will be cast to **integers** if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values **cannot be floating point**.

    Compatible **LHS** argument types: Register

    Compatible **RHS** argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    #### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |
    
    #### Pseudocode representation
        ```go
        if rhs = register
            lhs := lhs + reg_val(rhs)

        else if rhs = literal
            lhs := lhs + rhs

        else if rhs = reg_ptr
            lhs := lhs + memory[reg_val(rhs)]

        else if rhs = mem_ptr
            lhs := lhs + memory[memory[lhs]]
        ```

## 3. JO

    ### JO - Jump if the overflow flag is set

    `JO` performs a **conditional jump**, which sets the CPU's program counter to the destination specified. `JO` will only jump if the overflow flag on the CPU is set. This flag becomes set if an **arithmetic operation** (e.g. `add`, `mul`) overflows the **destination** register.

    When `JO` is performed, the memory address that it is **performed at** is "`push`ed" onto the call stack. This memory address is known as a *return address* and is retrieved if the jump is to be returned from. Thus, if a value is to be retrieved off the stack after `JO`, the return address must first be removed, or the stack and base pointers must be adjusted. 
    
    > **Note**: The value it pushes onto the stack may **overflow a memory address**, as memory address values are signed but the addresses themselves are not. Thus, if the program is **very large** or starts at a very high memory address, it may **not be feasible** to retrieve a jumped address as it may have overflowed. This is **unlikely** unless the assembly program is above **27,000 lines of source code**.

    The overflow flag can be set **unconditionally** with `int #21`, **unset** with `int #22`, and **inverted** with `int #23`.

    As subroutines and labels in assembly **resolve to memory addresses**, `JO` will always jump to a memory address if the jump location is a subroutine, granted the destination is small enough to fit within `11` bits.

    `JO` can also take a **register pointer** argument, meaning that the value in a register is interpreted as a memory address for the destination of a jump. This must be set manually, as the assembler **will not do this**.

    Using a register as the destination can be beneficial, as `r4` and `r5` are unsigned 16 bit integers, being **able to address all memory addresses**. It is also possible to pass `r6` or `r7` - the floating point registers - to this instruction.

    If the overflow flag is **not set**, the jump will **simply be skipped**, and the next instruction will be executed accordingly.

    > Note: Any jump instruction can overflow the stack if it is full

    Compatible DEST types: Register pointer, memory address

    Flags affected: Affected by overflow flag. Cannot change any flags.
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | JO   | 1         | Jump if overflow flag is true | Leaving a loop when a register overflows | `jo $3 ; jump to address 3 if overflow flag is set` |

    
    #### Binary encoding

        Instruction: `jo &r3`

        | Opcode   | DTB     | DEST |
        | :-----   | :------ | :--- |
        | `[0010]` | `[1]` | `[00000000011]` |

    #### Pseudocode representation
        ```go
        if zero_flag
            if sp > bp // adjust stack pointer
                sp := sp + 1
            else
                sp := sp - 1

            if sp < 0 || sp > 65535
                throw overflow_err

            memory[sp] := pc // push onto stack
            
            if dtb = 1
                pc := reg_val(dest)
            else 
                pc := memory[dest]
        else
            return
        ```

## 4. POP

    ### POP - Remove the top value of the call stack and place it into a register

    `POP` reads the stack pointer, and then "`pop`s" the value contained at the stack pointer into **a destination**. The destination can only **be a register**, and `POP` will only ever take one argument. The value at the **top of the call stack** - which is referenced with the stack pointer - will be **cleared**, and the stack pointer will be adjusted depending on the direction the call stack is "going". 

    If a `POP` instruction is called **whilst the stack pointer does not point to a value**, the CPU will report a *stack underflow* - a type of segmentation fault - where the call stack does not have enough data to satisfy a `POP` instruction.

    As the **memory** is composed of **signed 16 bit integers**, the values "`pop`ped" off it will always be 16 bit signed integers. Thus, it is typically unnecessary to `pop` into a floating point register or an unsigned 16-bit register.

    Compatible DEST argument types: Register

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | POP  | 1         | Take a value off the stack | Retrieving a memory address from a JMP | `pop %r4 ; pop a value off the stack into register 4` |

    
    #### Binary encoding

        Instruction: `pop %r2`

        | Opcode   | DEST    |
        | :-----   | :------ |
        | `[0011]` | `[000000000010]` |

    #### Pseudocode representation
        ```go
        if memory[sp] = NULL
            throw underflow_err

        dest := memory[sp]
        memory[sp] := NULL

        if sp > bp // adjust stack pointer
            sp := sp - 1
        else
            sp := sp + 1
        ```

## 5. DIV

    ### DIV - Divide LHS by RHS, storing the result in LHS

    `DIV` will perform **arithmetic division** between the two arguments passed to it, and the result will be **cast to an integer** if the destination is not a register **capable of storing floating point values** (any register that is not register 6 or 7). 

    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | DIV  | 2         | DIVide two values | Floating-point math | `div %r4, #3 ; divide value in r4 by 3` |

    
    #### Binary encoding

        Instruction: `div %r1, &$2`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0100]` | `[001]` | `[0100]` | `[00010]` |

    #### Pseudocode representation
        ```
        if rhs = register
            lhs := lhs / reg_val(rhs)

        else if rhs = literal
            lhs := lhs / rhs

        else if rhs = reg_ptr
            lhs := lhs / memory[reg_val(rhs)]

        else if rhs = mem_ptr
            lhs := lhs / memory[memory[lhs]]
        ```

## 6. RET

    ### RET - Return

    `RET` will read the value that the memory address that the stack pointer points to holds. The program counter will then be set to this address, and the memory address will be **cleared**. This instruction is similar to the `POP` instruction, however, it doesn't load the value **into a register**.

    `RET` takes no arguments.

    `RET` can be used after a **jump instruction** is called to return to where the jump instruction was called from if the return address is still on the **top of the call stack**. If not, it is possible to **create a return address** on the call stack by saving the return address after a jump, then **pushing it back** on before `RET` is called.

    #### Example:
        ```asm
        jmp @somewhere
        somewhere:
            pop %r4  ; save the return address
            push %r3 ; do other things with the stack
            ...
            push %r4 ; push the return address back on
            ret ; the first line should be returned to
        ```

    Compatible argument types: None

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | RET | None | Return | Returning from a jump | `ret` |

    
    #### Binary encoding

        Instruction: `ret`

        | Opcode   | Rest of instruction | 
        | :-----   | :------ |
        | `[0101]` | `[000000000000]` |

    #### Pseudocode representation
        ```go
        if memory[sp] = NULL
            throw underflow_err
        
        pc := memory[sp]
        memory[sp] := NULL

        if sp > bp // adjust stack pointer
            sp := sp - 1
        else
            sp := sp + 1

        ```

## 7. LD

    ### LD - Directly load from a memory address into a register

    `LD` will read the **memory address** provided by the **RHS**, and retrieve the value at the memory address specified. Then, the value will be loaded into the register provided by the **LHS** of the instruction. If no value is found, a **segmentation fault** will occur, and the emulator will halt.

    Compatible LHS argument types: Register

    Compatible RHS argument types: Memory address 

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | LD  | 2 | Load from address to register  | Loading to registers | `ld %r0, $40 ; load value at address 40 into r0`  |

    
    #### Binary encoding

        Instruction: `ld %r5, $42`

        | Opcode   | LHS     | RHS       | 
        | :-----   | :------ | :-------- |
        | `[0110]` | `[101]` | `[000101010]` |

    #### Pseudocode representation
    ```go
    if memory[rhs] = NULL
        throw segfault_err

    lhs := memory[rhs]
    ```

## 8. ST

    ### ST - Directly store into a memory address from a register

    `ST` takes two arguments, and retrieves the value in the RHS register and stores it into the LHS. LHS can be either a register pointer, or a direct memory address. This allows the `ST` instruction to addresses all addresses if used indirectly via a register pointer. `ST` will overwrite any data at the destination address, and it can also overwrite program memory if the destination address is also part of program memory. Using `ST` in conjunction with `LD` or with the call stack can allow for full usage of the memory of the BELLE-ISA.

    If a given register pointer is *negative*, the value will simply be stored at address 0.

    Compatible LHS argument types: Register pointer, memory address

    Compatible RHS argument types: Register

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ST | 2 | Store into an address | `<---` | `st $4, %r1 ; store r1 into addr 4` |

    
    #### Binary encoding

        Instruction: `st &r3, %r4`

        | Opcode   | DTB     | LHS     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0111]` | `[1]` | `[011]` | `[00000100]` |

    #### Pseudocode representation
    ```go
    if lhs = reg_ptr
        memory[reg_val(lhs)] := reg_val(rhs)

    else
        memory[lhs] := reg_val(rhs)
    ```
## 9. JMP

    ### JMP - Unconditional jump  

    `JMP` performs an **unconditional jump**, which sets the CPU's program counter to the destination specified.

    When `JMP` is performed, the memory address that it is **performed at** is "`push`ed" onto the call stack. This memory address is known as a *return address* and is retrieved if the jump is to be returned from. Thus, if a value is to be retrieved off the stack after `JMP`, the return address must first be removed, or the stack and base pointers must be adjusted. 
    
    > **Note**: The value it pushes onto the stack may **overflow a memory address**, as memory address values are signed but the addresses themselves are not. Thus, if the program is **very large** or starts at a very high memory address, it may **not be feasible** to retrieve a jumped address as it may have overflowed. This is **unlikely** unless the assembly program is above **27,000 lines of source code**.

    As subroutines and labels in assembly **resolve to memory addresses**, `JMP` will always jump to a memory address if the jump location is a subroutine, granted the destination is small enough to fit within `11` bits.

    `JMP` can also take a **register pointer** argument, meaning that the value in a register is interpreted as a memory address for the destination of a jump. This must be set manually, as the assembler **will not do this**.

    Using a register as the destination can be beneficial, as `r4` and `r5` are unsigned 16 bit integers, being **able to address all memory addresses**. It is also possible to pass `r6` or `r7` - the floating point registers - to this instruction.

    > Note: Any jump instruction can overflow the stack if it is full

    Compatible DEST types: Register pointer, memory address

    Flags affected: None 
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | JMP   | 1         | Jump | Recursion | `jmp $31 ; jump to address 31` |

    
    #### Binary encoding

        Instruction: `JMP $50`

        | Opcode   | DTB     | DEST |
        | :-----   | :------ | :--- |
        | `[0010]` | `[0]` | `[00000110010]` |

    #### Pseudocode representation
        ```go
        if sp > bp // adjust stack pointer
            sp := sp + 1
        else
            sp := sp - 1

        if sp < 0 || sp > 65535
            throw overflow_err

        memory[sp] := pc // push onto stack
            
        if dtb = 1
            pc := reg_val(dest)
        else 
            pc := memory[dest]
        ```


## 7. LD

    ### Placeholder - placeholder

    description

    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    |   |          |  |  |  |

    
    #### Binary encoding

        Instruction: ``

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `` | `` | `` | `` |

    #### Pseudocode representation
    ```go
    var x := 42
    ```
## 7. LD

    ### Placeholder - placeholder

    description

    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    |   |          |  |  |  |

    
    #### Binary encoding

        Instruction: ``

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `` | `` | `` | `` |

    #### Pseudocode representation
    ```go
    var x := 42
    ```
