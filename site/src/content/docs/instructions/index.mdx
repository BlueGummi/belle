---
title: 'Instructions'
author: 'BlueGummi'
tableOfContents:
    minHeadingLevel: 2
    maxHeadingLevel: 2
---

# Instruction listings

The BELLE-ISA has 16 instructions, which were mentioned in the above opcode table. Below is a description, definition, use case, and example of every instruction.

Please refer to the [encoding](../encoding) document for more information about the specifics on how certain arguments are encoded, particularly the meaning of "determinant bits" and the different encodings that each instruction can use. This document omits such information for brevity's sake, as it is already quite long.

## 1. HLT

    ### HLT - The HALT instruction
    
    `HLT` will halt BELLE when it is encountered. The program will stop and gracefully exit, and no other instructions will be performed. 

    In binary, it is simply 16 consecutive zeros, thus making it possible to call a halt instruction by simply loading a zero into a memory address and performing a jump to the address.

    `HLT` takes no arguments, and is not compatible with any argument types.

    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | HLT  | None      | Halt BELLE | Halting once the overflow flag is set. | `hlt ; Stop the program` |

    Flags affected: `running` state.

    ### Binary encoding

        Instruction: `hlt`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0000]` | `[000]` | `[0000]` | `[00000]` |

## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |

## 2. JO

    ### JO - Jump if the overflow flag is set

    `JO` performs a conditional jump, which sets the CPU's program counter to the destination specified. `JO` will only jump if the overflow flag on the CPU is set. This flag becomes set if an arithmetic operation (e.g. `add`, `mul`) overflows the destination register.

    The overflow flag can be set unconditionally with `int #21`, unset with `int #22`, and inverted with `int #23`.

    As subroutines and labels in assembly resolve to memory addresses, `JO` will always jump to a memory address if the jump location is a subroutine, granted the destination is small enough to fit within `11` bits.

    `JO` can also take a register pointer argument, meaning that the value in a register is interpreted as a memory address for the destination of a jump. This must be set manually, as the assembler will not do this.

    Using a register as the destination can be beneficial, as `r4` and `r5` are unsigned 16 bit integers, being able to address all memory addresses. It is also possible to pass `r6` or `r7` - the floating point registers - to this instruction.

    If the overflow flag is not set, the jump will simply be skipped, and the next instruction will be executed accordingly.

    Compatible DEST types: Register pointer, memory address

    Flags affected: Affected by overflow flag. Cannot change any flags.
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | JO   | 1         | Jump if overflow flag is true | Leaving a loop when a register overflows | `jo $3 ; jump to address 3 if overflow flag is set` |

    
    ### Binary encoding

        Instruction: `jo &r3`

        | Opcode   | DTB     | DEST |
        | :-----   | :------ | :--- |
        | `[0010]` | `[1]` | `[00000000011]` |


## 2. POP

    ### POP - Remove the top value of the call stack and place it into a register



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


## 2. ADD

    ### ADD - Add RHS to LHS, storing result in LHS

    `ADD` will perform arithmetic addition, taking the second operand (right-hand side), and adding it to the first operand (left-hand side), storing the result in the first operand. `ADD` will always take 2 arguments, and can also perform subtraction if the value in RHS is negative. 

    `ADD` will perform floating point arithmetic as the 6th and 7th registers are floating-point, however the values will be cast to integers if the destination is an integer register. 

    `ADD` can only perform floating-point-to-floating-point addition if the two floating-point registers are passed as arguments. Literal values cannot be floating point.



    Compatible LHS argument types: Register

    Compatible RHS argument types: Register, literal, register pointer, memory address pointer, can be signed and unsigned

    Flags affected: None
    
    | Name | Arguments | Description | Use case | Example |
    | :--- | :-------- | :---------: | :------- | :------ |
    | ADD  | 2         | ADD two values | Adding values in a Fibonacci sequence | `add %r0, #3 ; add 3 to r0` |

    
    ### Binary encoding

        Instruction: `add %r4, &r3`

        | Opcode   | LHS     | DTBs     | RHS       | 
        | :-----   | :------ | :------- | :-------- |
        | `[0001]` | `[100]` | `[0010]` | `[00011]` |


