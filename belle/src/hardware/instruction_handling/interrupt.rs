use crate::UnrecoverableError::*;
use crate::{config::CONFIG, *};
use colored::*;
use std::io::{self, Read, Write};
impl CPU {
    pub fn handle_int(&mut self, arg: &Argument) -> PossibleCrash {
        if self.fuzz {
            return Ok(());
        }
        let code = self.get_value(arg)? as i16;
        match code {
            -6 => {
                return Err(StackUnderflow(
                    self.ir,
                    self.pc,
                    Some(String::from("Intentionally generated by interrupt call")),
                ));
            }
            -5 => {
                return Err(self.generate_segfault("Intentionally generated by interrupt call"));
            }
            -4 => {
                return Err(IllegalInstruction(
                    self.ir,
                    self.pc,
                    Some(String::from("Intentionally generated by interrupt call")),
                ));
            }
            -3 => {
                return Err(DivideByZero(
                    self.ir,
                    self.pc,
                    Some(String::from("Intentionally generated by interrupt call")),
                ));
            }
            -2 => {
                return Err(InvalidRegister(
                    self.ir,
                    self.pc,
                    Some(String::from("Intentionally generated by interrupt call")),
                ));
            }
            -1 => {
                return Err(StackOverflow(
                    self.ir,
                    self.pc,
                    Some(String::from("Intentionally generated by interrupt call")),
                ));
            }
            0_i16..=5_i16 => {
                if CONFIG.verbose || CONFIG.debug {
                    print_b();
                    println!("╭─────────╮");
                    println!("│ {:^5}   │", self.int_reg[code as usize]);
                    println!("╰─────────╯");
                    print_t();
                } else {
                    println!("{}", self.int_reg[code as usize]);
                }
            }
            6 => {
                if CONFIG.verbose || CONFIG.debug {
                    print_b();
                    println!("╭─────────╮");
                    println!("│ {:^5.5} │", self.float_reg[0]);
                    println!("╰─────────╯");
                    print_t();
                } else {
                    println!("{}", self.float_reg[0]);
                }
            }
            7 => {
                if CONFIG.verbose || CONFIG.debug {
                    print_b();
                    println!("╭─────────╮");
                    println!("│ {:^5.5} │", self.float_reg[1]);
                    println!("╰─────────╯");
                    print_t();
                } else {
                    println!("{}", self.float_reg[1]);
                }
            }
            8 => {
                let starting_point = self.int_reg[0];
                let end_point = self.int_reg[1];
                let memory = &self.memory;
                let mut stringy = String::new();
                if end_point as usize >= memory.len() || starting_point as usize >= memory.len() {
                    return Err(self.generate_segfault(
                        "Segmentation fault. Memory index out of bounds on interrupt call 8.",
                    ));
                }

                for index in starting_point..end_point {
                    if index as usize >= memory.len() {
                        return Err(self.generate_segfault(
                            "Segmentation fault. Memory index out of bounds on interrupt call 8.",
                        ));
                    }

                    if let Some(value) = memory[index as usize] {
                        if CONFIG.verbose || CONFIG.debug {
                            stringy = format!("{}{}", stringy, value as u8 as char);
                        } else {
                            print!("{}", value as u8 as char);
                        }
                    }
                }
                if CONFIG.verbose || CONFIG.debug {
                    print_b();
                    let lines: Vec<&str> = stringy.lines().collect();
                    let max_length =
                        if lines.iter().map(|line| line.len()).max().unwrap_or(10) >= 10 {
                            lines.iter().map(|line| line.len()).max().unwrap_or(10)
                        } else {
                            12
                        };
                    if max_length >= 10 {
                        println!("╭{}╮", "─".repeat(max_length + 2));
                    } else {
                        println!("╭{}╮", "─".repeat(12));
                    }
                    if max_length >= 10 {
                        println!(
                            "│ {} {}│",
                            "CPU STDOUT".to_string().bold().cyan(),
                            " ".repeat(max_length - 10)
                        );
                    } else {
                        println!("│ {} │", "CPU STDOUT".to_string().bold().cyan());
                    }
                    if max_length >= 10 {
                        println!("├{}┤", "─".repeat(max_length + 2));
                    } else {
                        println!("├{}┤", "─".repeat(12));
                    }
                    for line in lines {
                        println!("│ {}{} │", line, " ".repeat(max_length - line.len()));
                    }
                    if max_length >= 10 {
                        println!("╰{}╯", "─".repeat(max_length + 2));
                    } else {
                        println!("╰{}╯", "─".repeat(12));
                    }
                    if !CONFIG.compact_print {
                        println!();
                    }
                    print_t();
                }
                io::stdout().flush().expect("Failed to flush stdout");
            }
            9 => {
                if CONFIG.verbose || CONFIG.debug {
                    print_b();
                    println!("╭─────────────────────────╮");
                    println!("│ CPU STDIN               │");
                    println!("│ Reading one character.. │");
                    println!("╰─────────────────────────╯\n");
                }
                use crossterm::terminal;
                terminal::enable_raw_mode().unwrap();
                let mut buffer = [0; 1];
                let _ = io::stdin().read_exact(&mut buffer);
                self.int_reg[0] = buffer[0] as u16;

                terminal::disable_raw_mode().unwrap();
                io::stdout().flush().expect("Failed to flush stdout");
                print_t();
            }
            10 => {
                std::thread::sleep(std::time::Duration::from_millis(
                    (self.int_reg[4] as u64) * 100,
                ));
            }
            11 => self.zflag = true,
            12 => self.zflag = false,
            13 => self.zflag = !self.zflag,
            21 => self.oflag = true,
            22 => self.oflag = false,
            23 => self.oflag = !self.oflag,
            30 => cls(),
            31 => self.rflag = true,
            32 => self.rflag = false,
            33 => self.rflag = !self.rflag,
            40 => {
                print_b();
                loop {
                    let mut input = String::new();
                    match io::stdin().read_line(&mut input) {
                        Ok(_) => match input.trim().parse::<u16>() {
                            Ok(value) => {
                                self.int_reg[0] = value;
                                break;
                            }
                            Err(e) => {
                                println!("{}", EmuError::ReadFail(e.to_string()));
                            }
                        },
                        Err(e) => {
                            println!("{}", EmuError::ReadFail(e.to_string()));
                        }
                    }
                }

                print_t();
            }
            41 => self.sflag = true,
            42 => self.sflag = false,
            43 => self.sflag = !self.sflag,

            60 => self.sp = self.int_reg[4],
            61 => self.bp = self.int_reg[4],
            70 => self.pushret = true,
            71 => self.pushret = false,
            _ => {}
        }
        self.pc += 1;
        Ok(())
    }
}

pub fn print_b() {
    if CONFIG.compact_print && CONFIG.verbose {
        println!("╰────────────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴─────╯");
    }
}

pub fn print_t() {
    if CONFIG.compact_print && CONFIG.verbose {
        println!("╭────────────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬─────╮");
    }
}
